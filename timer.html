<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Missile Timer (45:00 • 9×5)</title>
  <style>
    :root{
      --bg1:#2b0b4a;
      --bg2:#0b2b3a;
      --card:rgba(255,255,255,.08);
      --card2:rgba(255,255,255,.12);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --accent:#7c3aed;
      --accent2:#22d3ee;
      --good:#34d399;
      --bad:#fb7185;
      --shadow:0 20px 60px rgba(0,0,0,.45);
      --radius:22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    html,body{height:100%;}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background: radial-gradient(1200px 800px at 20% 30%, rgba(124,58,237,.55), transparent 60%),
                  radial-gradient(1200px 800px at 80% 20%, rgba(34,211,238,.45), transparent 55%),
                  linear-gradient(120deg, var(--bg1), var(--bg2));
      display:flex;
      align-items:center;
      justify-content:center;
      padding:28px;
      overflow:hidden;
    }
    .card{
      width:min(980px, 96vw);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.14);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:26px 26px 22px;
      position:relative;
      backdrop-filter: blur(10px);
    }
    .top{
      display:flex;
      justify-content:space-between;
      gap:18px;
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .title{
      display:flex;
      gap:12px;
      align-items:center;
    }
    .title h1{
      font-size:24px;
      margin:0;
      letter-spacing:.2px;
    }
    .pill{
      font-family:var(--mono);
      font-size:12px;
      color:rgba(255,255,255,.85);
      background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.14);
      padding:6px 10px;
      border-radius:999px;
    }
    .subtitle{
      margin-top:6px;
      color:var(--muted);
      font-size:14px;
      line-height:1.35;
    }

    .clockBlock{
      text-align:right;
      min-width:280px;
    }
    .time{
      font-family:var(--mono);
      font-size:72px;
      letter-spacing:2px;
      margin:0;
      line-height:1;
      text-shadow:0 6px 24px rgba(0,0,0,.35);
    }
    .metaRow{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      margin-top:12px;
      flex-wrap:wrap;
    }
    .chip{
      font-family:var(--mono);
      font-size:12px;
      padding:8px 12px;
      border-radius:999px;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      color:rgba(255,255,255,.82);
    }
    .chip.good{ color:var(--good); border-color:rgba(52,211,153,.35); background:rgba(52,211,153,.08); }
    .chip.bad{ color:var(--bad); border-color:rgba(251,113,133,.35); background:rgba(251,113,133,.08); }

    .barWrap{
      margin:22px 0 16px;
      height:14px;
      border-radius:999px;
      background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.12);
      overflow:hidden;
      position:relative;
    }
    .bar{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, var(--accent2), var(--accent));
      border-radius:999px;
      box-shadow:0 0 18px rgba(124,58,237,.40);
      transition: width .18s linear;
    }

    .dots{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:flex-end;
      margin-top:10px;
      opacity:.9;
    }
    .dot{
      width:10px;height:10px;border-radius:999px;
      background:rgba(255,255,255,.18);
      border:1px solid rgba(255,255,255,.16);
    }
    .dot.on{
      background:rgba(34,211,238,.60);
      box-shadow:0 0 18px rgba(34,211,238,.35);
      border-color:rgba(34,211,238,.38);
    }

    .controls{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      margin-top:8px;
    }
    button{
      appearance:none;
      border:none;
      cursor:pointer;
      color:var(--text);
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.14);
      padding:10px 14px;
      border-radius:14px;
      font-weight:600;
      letter-spacing:.2px;
      transition: transform .05s ease, background .2s ease, border-color .2s ease;
    }
    button:hover{ background:rgba(255,255,255,.12); }
    button:active{ transform:scale(.98); }
    .primary{
      background:linear-gradient(90deg, rgba(34,211,238,.25), rgba(124,58,237,.25));
      border-color:rgba(124,58,237,.35);
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(3, minmax(170px, 1fr));
      gap:12px;
      margin-top:14px;
    }
    .field{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      padding:10px 12px;
    }
    .label{
      font-family:var(--mono);
      font-size:12px;
      color:rgba(255,255,255,.70);
      margin-bottom:6px;
    }
    .row{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
    }
    input[type="number"], input[type="range"], select{
      width:100%;
      font-family:var(--mono);
      color:var(--text);
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.14);
      border-radius:12px;
      padding:10px 10px;
      outline:none;
    }
    select{ cursor:pointer; }
    .hint{
      margin-top:14px;
      color:rgba(255,255,255,.60);
      font-size:13px;
    }
    .warn{
      margin-top:10px;
      color:rgba(255,255,255,.62);
      font-size:12px;
      line-height:1.35;
      padding:10px 12px;
      border-radius:14px;
      border:1px dashed rgba(255,255,255,.18);
      background:rgba(255,255,255,.05);
    }
    .kbd{
      font-family:var(--mono);
      padding:.1rem .35rem;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.06);
    }
    @media (max-width:820px){
      .time{ font-size:56px; }
      .grid{ grid-template-columns: 1fr; }
      .clockBlock{ text-align:left; }
      .metaRow, .dots{ justify-content:flex-start; }
    }
  </style>
</head>
<body>
  <div class="card">
    <div class="top">
      <div>
        <div class="title">
          <h1>Missile Timer</h1>
          <span class="pill" id="modePill">45:00 • 9×5</span>
        </div>
        <div class="subtitle">
          45 minutes from zero. Auto 5-minute chunks. Loud alarm at each chunk end. Then victory ✨
        </div>
      </div>

      <div class="clockBlock">
        <p class="time" id="timeText">45:00</p>
        <div class="metaRow">
          <span class="chip" id="chunkChip">Chunk: 0 / 9</span>
          <span class="chip bad" id="statusChip">Status: Idle</span>
        </div>
        <div class="dots" id="dots"></div>
      </div>
    </div>

    <div class="barWrap"><div class="bar" id="bar"></div></div>

    <div class="controls">
      <button class="primary" id="startBtn">Start</button>
      <button id="pauseBtn">Pause</button>
      <button id="resetBtn">Reset</button>
    </div>

    <div class="grid">
      <div class="field">
        <div class="label">Chunk (minutes)</div>
        <div class="row">
          <input id="chunkMinutes" type="number" min="1" max="60" step="1" value="5"/>
        </div>
      </div>

      <div class="field">
        <div class="label">Total chunks</div>
        <div class="row">
          <input id="totalChunks" type="number" min="1" max="99" step="1" value="9"/>
        </div>
      </div>

      <div class="field">
        <div class="label">Alarm sound + volume</div>
        <div class="row" style="gap:10px;">
          <select id="soundMode">
            <option value="triple">Prominent (triple alarm)</option>
            <option value="siren">Space siren</option>
            <option value="beep">Soft beep</option>
          </select>
          <div style="min-width:120px;">
            <input id="volume" type="range" min="5" max="100" value="55"/>
          </div>
        </div>
      </div>
    </div>

    <div class="warn">
      Notion/Browser rule: sound needs one user gesture. So click <span class="kbd">Start</span> once to “arm” audio.  
      Background tabs/embeds can throttle visuals, but this version schedules alarms ahead in WebAudio to stay reliable.
    </div>

    <div class="hint">
      Tip: You can embed this in Notion using the URL: <span class="kbd">.../missile45.html</span>
    </div>
  </div>

<script>
(() => {
  // ---------- UI ----------
  const timeText = document.getElementById('timeText');
  const bar = document.getElementById('bar');
  const chunkChip = document.getElementById('chunkChip');
  const statusChip = document.getElementById('statusChip');
  const dotsEl = document.getElementById('dots');
  const modePill = document.getElementById('modePill');

  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');

  const chunkMinutesInput = document.getElementById('chunkMinutes');
  const totalChunksInput = document.getElementById('totalChunks');
  const soundMode = document.getElementById('soundMode');
  const volume = document.getElementById('volume');

  // ---------- Timer state ----------
  let running = false;
  let paused = false;

  let chunkMinutes = 5;
  let totalChunks = 9;

  let totalMs = chunkMinutes * totalChunks * 60 * 1000;
  let startPerf = 0;          // performance.now() at start
  let pausePerf = 0;          // performance.now() at pause
  let pausedAccumMs = 0;      // total paused duration
  let rafId = null;
  let tickInterval = null;    // fallback tick (when rAF throttled)

  // ---------- Audio scheduling ----------
  let audioCtx = null;
  let armed = false;
  let schedule = [];          // list of { tMs, type }
  let scheduledNodes = [];    // created nodes so we can stop/cleanup

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function fmt(ms){
    ms = Math.max(0, ms);
    const totalSec = Math.ceil(ms / 1000);
    const m = Math.floor(totalSec / 60);
    const s = totalSec % 60;
    return String(m).padStart(2,'0') + ":" + String(s).padStart(2,'0');
  }

  function setStatus(text, good){
    statusChip.textContent = "Status: " + text;
    statusChip.classList.toggle('good', !!good);
    statusChip.classList.toggle('bad', !good);
  }

  function rebuildDots(){
    dotsEl.innerHTML = "";
    for(let i=0;i<totalChunks;i++){
      const d = document.createElement('div');
      d.className = 'dot';
      dotsEl.appendChild(d);
    }
  }

  function setDots(completedChunks){
    const kids = [...dotsEl.children];
    kids.forEach((k, i) => k.classList.toggle('on', i < completedChunks));
  }

  function recomputeTotals(){
    chunkMinutes = clamp(parseInt(chunkMinutesInput.value || "5", 10), 1, 60);
    totalChunks = clamp(parseInt(totalChunksInput.value || "9", 10), 1, 99);
    totalMs = chunkMinutes * totalChunks * 60 * 1000;
    modePill.textContent = `${Math.round(totalMs/60000)}:00 • ${totalChunks}×${chunkMinutes}`;
    rebuildDots();
    setDots(0);
    updateUI(totalMs, 0);
  }

  function updateUI(remainingMs, elapsedMs){
    timeText.textContent = fmt(remainingMs);
    const p = elapsedMs / totalMs;
    bar.style.width = (clamp(p, 0, 1) * 100).toFixed(2) + "%";

    const completed = clamp(Math.floor(elapsedMs / (chunkMinutes*60*1000)), 0, totalChunks);
    chunkChip.textContent = `Chunk: ${completed} / ${totalChunks}`;
    setDots(completed);
  }

  // ---------- WebAudio alarm generator ----------
  function ensureAudio(){
    if(!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
  }

  async function armAudio(){
    ensureAudio();
    if(audioCtx.state !== "running"){
      try{ await audioCtx.resume(); } catch(e){}
    }
    armed = true;
  }

  function stopAllScheduledAudio(){
    scheduledNodes.forEach(n => {
      try{ n.stop && n.stop(); } catch(e){}
      try{ n.disconnect && n.disconnect(); } catch(e){}
    });
    scheduledNodes = [];
  }

  function playTone(atTime, pattern, gainValue){
    // pattern = array of [freqHz, durationSec]
    const g = audioCtx.createGain();
    g.gain.value = 0.0001;

    const master = clamp(parseInt(volume.value || "55", 10) / 100, 0.05, 1.0);
    const base = master * clamp(gainValue, 0.05, 1.0);

    g.connect(audioCtx.destination);

    let t = atTime;
    // smooth ramp in
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(base, t + 0.02);

    pattern.forEach(([freq, dur], idx) => {
      const o = audioCtx.createOscillator();
      o.type = "sine";
      o.frequency.setValueAtTime(freq, t);
      o.connect(g);
      o.start(t);
      o.stop(t + dur);
      scheduledNodes.push(o);

      // tiny gap between bursts
      t += dur + 0.03;
    });

    // ramp out
    g.gain.setTargetAtTime(0.0001, t, 0.02);
    scheduledNodes.push(g);
  }

  function scheduleAlarmsFromNow(){
    if(!armed) return; // user must click start once
    ensureAudio();
    stopAllScheduledAudio();

    const nowAudio = audioCtx.currentTime;
    const nowPerf = performance.now();

    const elapsedMs = (nowPerf - startPerf - pausedAccumMs);
    const remainingMs = Math.max(0, totalMs - elapsedMs);

    // Build schedule of upcoming chunk ends (in ms from start)
    schedule = [];
    for(let i=1;i<=totalChunks;i++){
      schedule.push({ tMs: i * chunkMinutes * 60 * 1000, type: (i === totalChunks ? "final" : "chunk") });
    }

    // Schedule future events relative to "startPerf"
    const mode = soundMode.value;

    schedule.forEach(evt => {
      const evtMsFromNow = evt.tMs - elapsedMs;
      if(evtMsFromNow <= 0) return; // already passed

      const when = nowAudio + (evtMsFromNow / 1000);

      if(mode === "beep"){
        // simple beep
        playTone(when, [[880, 0.14]], 0.35);
      } else if(mode === "siren"){
        // siren sweep (approximated by stepped tones)
        const siren = [];
        const freqs = [520, 660, 820, 980, 820, 660];
        freqs.forEach(f => siren.push([f, 0.10]));
        playTone(when, siren, 0.55);
      } else {
        // prominent triple alarm
        const triple = [[880,0.12],[880,0.12],[1040,0.16]];
        playTone(when, triple, 0.65);
      }

      // add a “victory” extra flourish at the very end
      if(evt.type === "final"){
        const victoryWhen = when + 0.35;
        const victory = [[523.25,0.10],[659.25,0.10],[783.99,0.14],[1046.5,0.18]];
        playTone(victoryWhen, victory, 0.55);
      }
    });
  }

  // ---------- Tick loop ----------
  function getElapsedMs(){
    const now = performance.now();
    if(!running) return 0;
    if(paused) return (pausePerf - startPerf - pausedAccumMs);
    return (now - startPerf - pausedAccumMs);
  }

  function tick(){
    if(!running) return;

    const elapsedMs = getElapsedMs();
    const remainingMs = totalMs - elapsedMs;

    updateUI(remainingMs, elapsedMs);

    if(remainingMs <= 0){
      running = false;
      paused = false;
      setStatus("Done", true);
      cancelAnimationFrame(rafId);
      rafId = null;
      clearInterval(tickInterval);
      tickInterval = null;
      // (audio already scheduled for final)
    }
  }

  function startLoop(){
    // Use rAF + interval fallback
    const loop = () => {
      tick();
      rafId = requestAnimationFrame(loop);
    };
    if(!rafId) rafId = requestAnimationFrame(loop);

    if(!tickInterval){
      tickInterval = setInterval(() => {
        // helps when rAF is throttled in background
        tick();
      }, 250);
    }
  }

  // ---------- Actions ----------
  async function onStart(){
    // Always arm audio on Start (user gesture)
    await armAudio();

    if(!running){
      recomputeTotals();
      running = true;
      paused = false;
      pausedAccumMs = 0;
      startPerf = performance.now();
      setStatus("Running", true);
      scheduleAlarmsFromNow();
      startLoop();
      return;
    }

    if(paused){
      // resume
      paused = false;
      pausedAccumMs += (performance.now() - pausePerf);
      setStatus("Running", true);
      scheduleAlarmsFromNow(); // re-schedule remaining alarms
    }
  }

  function onPause(){
    if(!running) return;
    if(!paused){
      paused = true;
      pausePerf = performance.now();
      setStatus("Paused", false);
      // Stop any scheduled future audio while paused
      stopAllScheduledAudio();
    }
  }

  function onReset(){
    running = false;
    paused = false;
    pausedAccumMs = 0;
    startPerf = 0;
    pausePerf = 0;

    stopAllScheduledAudio();

    cancelAnimationFrame(rafId);
    rafId = null;
    clearInterval(tickInterval);
    tickInterval = null;

    recomputeTotals();
    updateUI(totalMs, 0);
    chunkChip.textContent = `Chunk: 0 / ${totalChunks}`;
    setStatus("Idle", false);
  }

  // When tab becomes visible again, refresh UI and (re)arm schedule if running
  document.addEventListener('visibilitychange', () => {
    if(document.visibilityState === 'visible'){
      if(running && !paused){
        // Update UI immediately and re-schedule remaining alarms
        tick();
        scheduleAlarmsFromNow();
      }
    }
  });

  // Changing sound mode/volume while running should re-schedule remaining alarms
  function rescheduleIfRunning(){
    if(running && !paused && armed){
      scheduleAlarmsFromNow();
    }
  }

  // ---------- Wire up ----------
  startBtn.addEventListener('click', onStart);
  pauseBtn.addEventListener('click', onPause);
  resetBtn.addEventListener('click', onReset);

  chunkMinutesInput.addEventListener('change', () => { onReset(); });
  totalChunksInput.addEventListener('change', () => { onReset(); });
  soundMode.addEventListener('change', rescheduleIfRunning);
  volume.addEventListener('input', rescheduleIfRunning);

  // Init
  recomputeTotals();
  onReset();
})();
</script>
</body>
</html>
