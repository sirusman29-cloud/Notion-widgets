<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Missile Timer (45:00 • 9×5)</title>
  <style>
    :root{
      --bg1:#2b0b4a;
      --bg2:#0b2b3a;
      --card:rgba(255,255,255,.08);
      --card2:rgba(255,255,255,.12);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --accent:#7c3aed;
      --accent2:#22d3ee;
      --good:#34d399;
      --bad:#fb7185;
      --shadow:0 20px 60px rgba(0,0,0,.45);
      --radius:22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
      color:var(--text);
      font-family:var(--sans);
      background:
        radial-gradient(1200px 700px at 25% 30%, rgba(124,58,237,.55), transparent 55%),
        radial-gradient(1100px 700px at 80% 45%, rgba(34,211,238,.35), transparent 55%),
        linear-gradient(120deg, var(--bg1), var(--bg2));
    }

    .panel{
      width:min(980px, 100%);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.12);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:26px;
      position:relative;
      overflow:hidden;
    }

    .top{
      display:flex;
      justify-content:space-between;
      gap:20px;
      align-items:flex-start;
    }

    .title{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .title h1{
      margin:0;
      font-size:28px;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .pill{
      font-family:var(--mono);
      font-size:13px;
      padding:6px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.14);
      color:var(--muted);
    }
    .subtitle{
      color:var(--muted);
      font-size:14px;
      line-height:1.35;
    }

    .bigtime{
      text-align:right;
      min-width:240px;
    }
    .bigtime .time{
      font-family:var(--mono);
      font-size:68px;
      line-height:1;
      letter-spacing:2px;
      margin:0;
      user-select:none;
    }
    .bigtime .meta{
      margin-top:10px;
      display:flex;
      justify-content:flex-end;
      gap:10px;
      flex-wrap:wrap;
    }
    .chip{
      padding:8px 12px;
      border-radius:999px;
      background:rgba(0,0,0,.12);
      border:1px solid rgba(255,255,255,.14);
      color:var(--muted);
      font-size:13px;
      font-family:var(--mono);
    }
    .chip.good{color:var(--good); border-color:rgba(52,211,153,.35)}
    .chip.bad{color:var(--bad); border-color:rgba(251,113,133,.35)}

    .progress-wrap{
      margin-top:22px;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      border-radius:999px;
      height:12px;
      overflow:hidden;
    }
    .progress{
      height:100%;
      width:0%;
      background:linear-gradient(90deg, var(--accent2), var(--accent));
      border-radius:999px;
      transition:width .2s linear;
    }

    .row{
      display:flex;
      gap:14px;
      flex-wrap:wrap;
      margin-top:18px;
      align-items:center;
    }
    button{
      appearance:none;
      border:none;
      cursor:pointer;
      padding:12px 16px;
      border-radius:14px;
      color:var(--text);
      background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.14);
      box-shadow:0 8px 24px rgba(0,0,0,.18);
      font-weight:600;
      transition:transform .06s ease, background .12s ease;
    }
    button:active{ transform:translateY(1px) }
    button.primary{
      background:linear-gradient(90deg, rgba(34,211,238,.25), rgba(124,58,237,.28));
      border-color:rgba(255,255,255,.18);
    }
    button.ghost{
      background:rgba(255,255,255,.07);
    }
    button:disabled{
      cursor:not-allowed;
      opacity:.55;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.2fr 1fr 1.2fr;
      gap:14px;
      margin-top:14px;
    }
    .box{
      background:rgba(0,0,0,.10);
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;
      padding:14px;
    }
    .label{
      color:var(--muted);
      font-size:12px;
      font-family:var(--mono);
      margin-bottom:8px;
    }
    input, select{
      width:100%;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.08);
      color:var(--text);
      font-family:var(--mono);
      outline:none;
    }
    input[type="range"]{
      padding:0;
      height:30px;
    }
    .inline{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .mini{
      font-size:12px;
      color:var(--muted);
      line-height:1.35;
      margin-top:10px;
      font-family:var(--mono);
    }
    .dots{
      display:flex;
      justify-content:flex-end;
      gap:8px;
      margin-top:10px;
    }
    .dot{
      width:10px; height:10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
    }
    .dot.on{ background:rgba(34,211,238,.55); border-color:rgba(34,211,238,.75) }

    .warn{
      margin-top:14px;
      padding:12px 14px;
      border-radius:16px;
      background:rgba(0,0,0,.14);
      border:1px solid rgba(255,255,255,.12);
      color:var(--muted);
      font-family:var(--mono);
      font-size:12px;
      line-height:1.4;
    }
    .blink{
      animation:blink .35s ease 0s 2;
    }
    @keyframes blink{
      0%{ filter:brightness(1) }
      50%{ filter:brightness(1.25) }
      100%{ filter:brightness(1) }
    }

    @media (max-width:820px){
      .top{flex-direction:column}
      .bigtime{ text-align:left; min-width:auto }
      .bigtime .time{ font-size:56px }
      .dots{justify-content:flex-start}
      .grid{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
  <div class="panel" id="panel">
    <div class="top">
      <div class="title">
        <h1>
          Missile Timer
          <span class="pill">45:00 • 9×5</span>
        </h1>
        <div class="subtitle">
          Exact chunk alarms (no drift). Each 5-minute boundary triggers an alarm. Then stop at chunk 9. ✨
        </div>
      </div>

      <div class="bigtime">
        <p class="time" id="time">45:00</p>
        <div class="meta">
          <span class="chip" id="chunkChip">Chunk: 1 / 9</span>
          <span class="chip" id="statusChip">Status: Ready</span>
        </div>
        <div class="dots" id="dots"></div>
      </div>
    </div>

    <div class="progress-wrap">
      <div class="progress" id="progress"></div>
    </div>

    <div class="row">
      <button class="primary" id="startBtn">Start</button>
      <button class="ghost" id="pauseBtn" disabled>Pause</button>
      <button class="ghost" id="resetBtn">Reset</button>
      <button class="ghost" id="testBtn">Test alarm</button>
    </div>

    <div class="grid">
      <div class="box">
        <div class="label">Chunk (minutes)</div>
        <input id="chunkMin" type="number" min="1" max="60" value="5" />
        <div class="mini">Default 5. Changes apply on <b>Reset</b>.</div>
      </div>

      <div class="box">
        <div class="label">Total chunks</div>
        <input id="totalChunks" type="number" min="1" max="60" value="9" />
        <div class="mini">Default 9. Total time = chunk × chunks.</div>
      </div>

      <div class="box">
        <div class="label">Alarm sound + volume</div>
        <div class="inline" style="margin-bottom:10px;">
          <select id="soundType">
            <option value="siren" selected>Space siren (loud)</option>
            <option value="ping">Laser ping (sharp)</option>
            <option value="gong">Deep gong (heavy)</option>
            <option value="beep">Classic beep</option>
          </select>
        </div>
        <div class="inline">
          <input id="volume" type="range" min="0" max="100" value="70" />
          <span class="pill" id="volLabel">70%</span>
        </div>
        <div class="mini">Sound is WebAudio. You must click <b>Start</b> once to unlock audio (browser rule).</div>
      </div>
    </div>

    <div class="warn">
      Note: Some browsers throttle visuals when minimized. This timer keeps alarms accurate by scheduling them on the audio clock.  
      If your browser fully suspends background audio, no webpage can force sound. (But timing won’t drift.)
    </div>
  </div>

<script>
(() => {
  // ---------- DOM ----------
  const panel = document.getElementById('panel');
  const timeEl = document.getElementById('time');
  const progressEl = document.getElementById('progress');
  const chunkChip = document.getElementById('chunkChip');
  const statusChip = document.getElementById('statusChip');
  const dotsEl = document.getElementById('dots');

  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const testBtn  = document.getElementById('testBtn');

  const chunkMinInput = document.getElementById('chunkMin');
  const totalChunksInput = document.getElementById('totalChunks');
  const soundTypeSel = document.getElementById('soundType');
  const volumeRange = document.getElementById('volume');
  const volLabel = document.getElementById('volLabel');

  // ---------- State ----------
  let running = false;
  let done = false;

  let chunkMin = 5;
  let totalChunks = 9;

  let totalMs = 45 * 60 * 1000;
  let chunkMs = 5 * 60 * 1000;

  // timer clock (UI)
  let startPerf = 0;
  let pausedTotal = 0;
  let pausePerf = 0;

  let rafId = null;

  // Audio clock
  let audioCtx = null;
  let scheduled = []; // nodes to cancel on reset
  let scheduleBaseTime = 0; // audioCtx.currentTime at start

  // ---------- Helpers ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const fmt2 = n => String(n).padStart(2, '0');

  function fmtTime(ms){
    ms = Math.max(0, ms);
    const s = Math.floor(ms/1000);
    const m = Math.floor(s/60);
    const r = s % 60;
    return `${fmt2(m)}:${fmt2(r)}`;
  }

  function setStatus(text, tone){
    statusChip.textContent = `Status: ${text}`;
    statusChip.classList.remove('good','bad');
    if (tone === 'good') statusChip.classList.add('good');
    if (tone === 'bad') statusChip.classList.add('bad');
  }

  function readSettings(){
    const cm = clamp(parseInt(chunkMinInput.value || '5', 10), 1, 60);
    const tc = clamp(parseInt(totalChunksInput.value || '9', 10), 1, 60);
    chunkMin = cm;
    totalChunks = tc;
    chunkMs = chunkMin * 60 * 1000;
    totalMs = chunkMs * totalChunks;
    buildDots();
    chunkChip.textContent = `Chunk: 1 / ${totalChunks}`;
    timeEl.textContent = fmtTime(totalMs);
    progressEl.style.width = `0%`;
  }

  function buildDots(){
    dotsEl.innerHTML = '';
    for(let i=0;i<totalChunks;i++){
      const d = document.createElement('div');
      d.className = 'dot' + (i===0 ? ' on' : '');
      dotsEl.appendChild(d);
    }
  }

  function setDots(activeChunkIndex){
    const dots = dotsEl.querySelectorAll('.dot');
    dots.forEach((d,i)=> d.classList.toggle('on', i === activeChunkIndex));
  }

  function elapsedMs(){
    const t = running ? performance.now() : pausePerf;
    return Math.max(0, t - startPerf - pausedTotal);
  }

  // ---------- WebAudio: sound design ----------
  function ensureAudio(){
    if (audioCtx) return audioCtx;
    const AC = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AC();
    return audioCtx;
  }

  function volGain(){
    const v = clamp(parseInt(volumeRange.value || '70', 10), 0, 100);
    return v / 100;
  }

  function scheduleAlarmAt(type, whenSec, gain01){
    // Create nodes now, start in the future at whenSec
    const ctx = audioCtx;
    const master = ctx.createGain();
    master.gain.setValueAtTime(0.0001, whenSec);
    master.gain.linearRampToValueAtTime(gain01, whenSec + 0.01);
    master.gain.exponentialRampToValueAtTime(0.0001, whenSec + 1.15);
    master.connect(ctx.destination);

    const stopAt = whenSec + 1.2;

    if (type === 'beep'){
      const o = ctx.createOscillator();
      o.type = 'sine';
      o.frequency.setValueAtTime(880, whenSec);
      o.frequency.exponentialRampToValueAtTime(660, whenSec + 0.25);
      o.connect(master);
      o.start(whenSec);
      o.stop(stopAt);
      scheduled.push(o, master);
      return;
    }

    if (type === 'ping'){
      // 2 sharp pings
      const mk = (t, f1, f2) => {
        const g = ctx.createGain();
        g.gain.setValueAtTime(0.0001, t);
        g.gain.linearRampToValueAtTime(gain01, t + 0.005);
        g.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);
        g.connect(ctx.destination);

        const o = ctx.createOscillator();
        o.type = 'triangle';
        o.frequency.setValueAtTime(f1, t);
        o.frequency.exponentialRampToValueAtTime(f2, t + 0.12);
        o.connect(g);
        o.start(t);
        o.stop(t + 0.20);
        scheduled.push(o, g);
      };
      mk(whenSec, 1400, 900);
      mk(whenSec + 0.22, 1200, 700);
      scheduled.push(master); // not used, but keep symmetry
      return;
    }

    if (type === 'gong'){
      // layered low partials
      const partials = [
        {f: 220, type:'sine'},
        {f: 330, type:'sine'},
        {f: 110, type:'triangle'},
      ];
      partials.forEach((p, idx) => {
        const o = ctx.createOscillator();
        o.type = p.type;
        o.frequency.setValueAtTime(p.f, whenSec);
        // slight detune wobble
        o.detune.setValueAtTime((idx-1)*6, whenSec);
        o.connect(master);
        o.start(whenSec);
        o.stop(stopAt);
        scheduled.push(o);
      });
      scheduled.push(master);
      return;
    }

    // siren (default): sweeping tone with tremolo
    {
      const o = ctx.createOscillator();
      o.type = 'sawtooth';
      o.frequency.setValueAtTime(520, whenSec);
      o.frequency.linearRampToValueAtTime(980, whenSec + 0.35);
      o.frequency.linearRampToValueAtTime(620, whenSec + 0.70);
      o.frequency.linearRampToValueAtTime(1100, whenSec + 1.05);

      // tremolo
      const lfo = ctx.createOscillator();
      const lfoGain = ctx.createGain();
      lfo.frequency.setValueAtTime(9, whenSec);
      lfoGain.gain.setValueAtTime(0.35, whenSec);

      lfo.connect(lfoGain);
      lfoGain.connect(master.gain);

      o.connect(master);
      o.start(whenSec);
      o.stop(stopAt);
      lfo.start(whenSec);
      lfo.stop(stopAt);

      scheduled.push(o, lfo, lfoGain, master);
    }
  }

  function clearScheduled(){
    for (const n of scheduled){
      try{
        if (typeof n.stop === 'function') n.stop(0);
      }catch(e){}
      try{
        if (typeof n.disconnect === 'function') n.disconnect();
      }catch(e){}
    }
    scheduled = [];
  }

  function scheduleAllChunkAlarms(){
    clearScheduled();
    const ctx = audioCtx;
    const type = soundTypeSel.value;
    const g = volGain();

    // Anchor alarms to audio clock start time (this is the key!)
    scheduleBaseTime = ctx.currentTime;

    // Beep at EACH chunk end: 1..totalChunks (includes final completion)
    for (let i = 1; i <= totalChunks; i++){
      const when = scheduleBaseTime + (i * (chunkMs / 1000));
      scheduleAlarmAt(type, when, g);
    }
  }

  async function armAudioAndSchedule(){
    const ctx = ensureAudio();
    // Must resume on user gesture
    if (ctx.state !== 'running'){
      await ctx.resume();
    }
    scheduleAllChunkAlarms();
  }

  // ---------- UI update loop ----------
  function update(){
    const e = elapsedMs();
    const remaining = totalMs - e;

    // chunk math
    const chunkIndex = clamp(Math.floor(e / chunkMs), 0, totalChunks - 1); // 0-based current chunk
    const chunkElapsed = e - (chunkIndex * chunkMs);
    const chunkRemaining = chunkMs - chunkElapsed;

    // UI
    timeEl.textContent = fmtTime(remaining);
    chunkChip.textContent = `Chunk: ${chunkIndex + 1} / ${totalChunks}`;
    setDots(chunkIndex);

    const pct = clamp((e / totalMs) * 100, 0, 100);
    progressEl.style.width = `${pct}%`;

    // finish
    if (!done && remaining <= 0){
      done = true;
      running = false;
      pauseBtn.disabled = true;
      startBtn.disabled = false;
      setStatus('Completed', 'good');
      panel.classList.add('blink');
      setTimeout(()=>panel.classList.remove('blink'), 500);
      cancelAnimationFrame(rafId);
      rafId = null;
      return;
    }

    if (running) rafId = requestAnimationFrame(update);
  }

  // ---------- Controls ----------
  function lockInputs(lock){
    chunkMinInput.disabled = lock;
    totalChunksInput.disabled = lock;
    soundTypeSel.disabled = lock;
  }

  async function start(){
    if (done) reset();

    // Read settings only if not running (so it doesn't change mid-flight)
    readSettings();

    // Arm audio + schedule alarms on audio clock
    try{
      await armAudioAndSchedule();
    }catch(e){
      // Audio blocked; still run timer visuals
      console.warn('Audio could not start:', e);
    }

    // Start / resume timer clock
    if (!running){
      if (startPerf === 0){
        startPerf = performance.now();
        pausedTotal = 0;
      } else {
        // Resume
        pausedTotal += performance.now() - pausePerf;
      }
      running = true;
      setStatus('Running', 'good');
      startBtn.disabled = true;
      pauseBtn.disabled = false;
      lockInputs(true);

      // Keep audio paused/resumed in sync with timer
      if (audioCtx && audioCtx.state !== 'running'){
        try{ await audioCtx.resume(); }catch(e){}
      }

      if (!rafId) rafId = requestAnimationFrame(update);
    }
  }

  async function pause(){
    if (!running) return;
    running = false;
    pausePerf = performance.now();
    setStatus('Paused', 'bad');
    startBtn.disabled = false;
    pauseBtn.disabled = true;

    // Suspend audio clock so scheduled alarms also pause (no drift!)
    if (audioCtx && audioCtx.state === 'running'){
      try{ await audioCtx.suspend(); }catch(e){}
    }
  }

  async function reset(){
    running = false;
    done = false;

    // Stop UI loop
    if (rafId){
      cancelAnimationFrame(rafId);
      rafId = null;
    }

    // Stop scheduled alarms
    if (audioCtx){
      try{ await audioCtx.suspend(); }catch(e){}
    }
    clearScheduled();

    // Reset timer clock
    startPerf = 0;
    pausedTotal = 0;
    pausePerf = 0;

    // Rebuild defaults/UI
    readSettings();
    setStatus('Ready');
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    lockInputs(false);
  }

  async function testAlarm(){
    try{
      const ctx = ensureAudio();
      if (ctx.state !== 'running') await ctx.resume();

      const type = soundTypeSel.value;
      const g = volGain();
      const t = ctx.currentTime + 0.02;
      // play a single alarm immediately (not scheduled list)
      scheduleAlarmAt(type, t, g);
      panel.classList.add('blink');
      setTimeout(()=>panel.classList.remove('blink'), 450);
    }catch(e){
      console.warn(e);
    }
  }

  // ---------- Events ----------
  startBtn.addEventListener('click', start);
  pauseBtn.addEventListener('click', pause);
  resetBtn.addEventListener('click', reset);
  testBtn.addEventListener('click', testAlarm);

  volumeRange.addEventListener('input', () => {
    volLabel.textContent = `${clamp(parseInt(volumeRange.value || '0',10),0,100)}%`;
  });

  // settings changed
  chunkMinInput.addEventListener('change', () => { if (!running) readSettings(); });
  totalChunksInput.addEventListener('change', () => { if (!running) readSettings(); });

  // Init
  volLabel.textContent = `${volumeRange.value}%`;
  readSettings();
})();
</script>
</body>
</html>
